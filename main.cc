// #define MONITOR_ONLY   // don't servo, just monitor.
// #define LOGGING_PFD    // logging pfd states, lead, lock, lag & reference, feedback signals phase 
#define LOGGING_BASIC  // logging frequency, manipulate factor, etc...

#define Kp_PARAM (-0.001f)
// #define Kp_PARAM (-0.05f)
#define Kd_PARAM (-0.05f)

#include "gpio.h"
#include "reset.h"
#include "tty.h"
#include "motor.h"
#include "clock.h"
#include "tui.h"
#include <stdio.h>
#include <stdint.h>
#include <thread>
#include <stdlib.h>
#include <fstream>
#include <signal.h>
#include <string>
#include <ctime>

void signal_handler(int signum){
	tty_sig_handler(signum);
	gpio_sig_handler();
	reset_sig_handler();
	clock_sig_handler();
	mem_sig_handler();
	exit(EXIT_FAILURE);
}

int main(int argc, char** argv){
	/* set signal handler */
	signal(SIGINT, signal_handler);
	signal(SIGTERM,signal_handler);

	/* setup process */
	mem_setup();
	tty_setup();
	gpio_setup();
	reset_setup();
	clock_setup();

	/* logger setup */
#ifdef LOGGING_BASIC
	std::ofstream stream("../LOG/" + std::to_string(time(nullptr)) + ".csv");
	stream <<  "count" << "," 
		<< "P_term" << ","
		<< "I_term" << ","
		<< "D_term" << ","
		<< "PID_term" << ","
		<< "RefFreq" << ","
		<< "FedFreq" << ","
		<< "ErrFreq" << std::endl; 
#endif

	/* PFD logger setup */
#ifdef LOGGING_PFD
	std::ofstream pfd_stream("../PFD_LOG/" + std::to_string(time(nullptr)) + ".vcd");
	pfd_stream << R"(
$version Generated by PLL-OFC program made by Masaru Nishimura $end
$date Sat Nov 27 11:55:32 2021 $end
$timescale 1ns $end
$scope module PFD $end
$var wire 1 ( feedback $end
$var wire 1 ) reference $end
$var reg 1 < lead $end
$var reg 1 / lock $end
$var reg 1 > lag $end
$upscope $end
$enddefinitions $end
$dumpvars
0(
0)
x<
x/
x>
$end
)";
#endif

	refclk_set_clk0_div(0x3E, 0x694);
	usleep(1000);
	refclk_apply_setting();
	
	printf("%x\n", intclk_get_div());
	intclk_set_div(0x3F);
	usleep(1000);
	intclk_apply_setting();

	std::cout << time(nullptr) << std::endl;

#ifndef MONITOR_ONLY
	if (init_motor() == -1){
		tty_exit();
		gpio_exit();
		reset_exit();
		clock_setup();
		mem_exit();
		perror("Initialize Stepping-Motor FAILED");
		exit(EXIT_FAILURE);
	} else {
		puts("Initialize Stepping-Motor SUCCESS");
	}
#endif

	gpio_setParamP(Kp_PARAM);
	gpio_setParamD(Kd_PARAM);
 	reset_fclk1();

	std::thread servo_thread(
			[&]{
#ifndef MONITOR_ONLY
			while (1)
			servo_motor(); 
#endif
			});
	std::thread gui_thread(build_GUI);

#ifdef LOGGING_BASIC
	std::thread logging_thread(
			[&]{
			unsigned long long count = 0;
			sleep(1);
			while (1) {
			stream << count++     << "," 
			<< accum_P << ","
			<< gpio_getI() << ","
			<< gpio_getD() << ","
			<< q << ","
			<< gpio_getRefFreq() << ","
			<< gpio_getFedFreq() << ","
			<< gpio_getErrFreq() << std::endl; 
			usleep(500000); // reflesh 2 times in 1 sec
			}});
#endif 

#ifdef LOGGING_PFD
	std::thread pfd_logging_thread(
			[&]{
			unsigned long long count = 0;
			sleep(1);
			while(1) {
				auto sig = gpio_getPhaseSig();
				auto state = gpio_getPhaseState();
				pfd_stream << "#" << count++ << std::endl;
				pfd_stream << char(sig.feedback + 0x30)  << "(" << std::endl;    // feedback
				pfd_stream << char(sig.reference + 0x30) << ")" << std::endl;    // reference
				pfd_stream << char(state.lead + 0x30) << "<" << std::endl;    // lead
				pfd_stream << char(state.lock + 0x30) << "/" << std::endl;    // lock
				pfd_stream << char(state.lag  + 0x30) << ">" << std::endl;    // lag
				usleep(1000); // reflesh 100 times in 1 sec
			}});
#endif

	gui_thread.join();
	servo_thread.join();

	/* close logger */
#ifdef LOGGING_BASIC
	logging_thread.join();
       	stream.close();
#endif
#ifdef LOGGING_PFD
	pfd_logging_thread.join();
	pfd_stream.close();
#endif
	
	/* exit process */
	tty_exit();
	gpio_exit();
	reset_exit();
	clock_exit();
	mem_exit();

	return 0;
}
